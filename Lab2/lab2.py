# -*- coding: utf-8 -*-
"""Lab2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OjxAi6n5Edov-I-IB2EFmLtJLCbc5uex
"""

pip install scikit-image

pip install livelossplot

from skimage import io, transform
import cv2
import numpy as np
from glob import glob
from google.colab import drive
import matplotlib.pyplot as plt
from random import randint
import tensorflow as tf
from keras.datasets import mnist
#from keras.models import Sequential
from keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten
from keras.utils import np_utils
from keras.initializers import RandomNormal, RandomUniform, Constant
from livelossplot import PlotLossesKeras



drive.mount("/content/gdrive")
withglasses_path = glob('/content/gdrive/My Drive/Photos/CropWithGlasses/*.jpg')
withoutglasses_path = glob('/content/gdrive/My Drive/Photos/CropWithoutGlasses/*.jpg')

print(len(withglasses_path))
print(len(withoutglasses_path))

amount = 714
width = 128
encoding_dim = 32
#size = len(uninfected_path)
test_size = 114
train_size = 600

withoutGlasess_test_path = withoutglasses_path[0:test_size]
withGlasess_test_path = withglasses_path[0:test_size]
withoutGlasess_train_path = withoutglasses_path[test_size:test_size + train_size]
withGlasess_train_path = withglasses_path[test_size:test_size + train_size]

def updateData(path, directory):
  index = 1
  for p in path:
    image = cv2.imread(p)
    #image = image[0:3024, 504:(3024+504)]
    image = image[504:(3024+504), 0:3024]
    cv2.imwrite(directory + str(index) + '.jpg', image)
    index += 1

#updateData(withglasses_path, '/content/gdrive/My Drive/Photos/CropWithGlasses/')
#updateData(withoutglasses_path, '/content/gdrive/My Drive/Photos/CropWithoutGlasses/')

def rotate_image(image, angle):
  image_center = tuple(np.array(image.shape[1::-1]) / 2)
  rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)
  result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)
  return result

def loadData(path):
  data = np.array([])
  for p in path:
    image = cv2.imread(p)
    image = cv2.resize(image, (width, width))
    data = np.append(data, image)
    data = np.append(data, rotate_image(image, 3))
    img_flipped = cv2.flip(image, 1)
    data = np.append(data, img_flipped)
  return data

trainX = loadData(withoutGlasess_train_path)
trainX_noise = loadData(withGlasess_train_path)
testX = loadData(withoutGlasess_test_path)
testX_noise = loadData(withGlasess_test_path)

#trainX = np.array([])

#for path in uninfected_train_path + parasitized_train_path:
#    image = io.imread(path)
#    new_size = [width, width]
#    img = transform.resize(image, new_size)
#    trainX = np.append(trainX, img)
#trainX = np.reshape(trainX, (train_size * 2, width * width * 3))
#trainX /= 255.0

trainX = trainX.astype('float32') / 255.
trainX_noise = trainX_noise.astype('float32') / 255.
testX = testX.astype('float32') / 255.
testX_noise = testX_noise.astype('float32') / 255.

trainX = np.reshape(trainX, (train_size * 3, width * width * 3))
trainX_noise = np.reshape(trainX_noise, (train_size * 3, width * width * 3))
testX = np.reshape(testX, (test_size * 3, width * width * 3))
testX_noise = np.reshape(testX_noise, (test_size * 3, width * width * 3))

print(len(trainX))

#input_img = keras.Input(shape=(784,))
from keras import layers
import keras
input_img = keras.Input(shape=(width * width * 3,))
encoded = layers.Dense(1000, activation='softmax')(input_img)
encoded = layers.Dense(500, activation='softmax')(encoded)
encoded = layers.Dense(250, activation='softmax')(encoded)
encoded = layers.Dense(150, activation='softmax')(encoded)

encoded = layers.Dense(100, activation='softmax')(encoded)
#encoded = layers.Dense(100, activation='relu')(encoded)

decoded = layers.Dense(150, activation='softmax')(encoded)
decoded = layers.Dense(250, activation='softmax')(decoded)
decoded = layers.Dense(500, activation='softmax')(decoded)
decoded = layers.Dense(1000, activation='softmax')(decoded)
decoded = layers.Dense(width * width * 3, activation='sigmoid')(decoded)

#from keras import layers
#import keras
#input_img = keras.Input(shape=(28 * 28,))
#encoded = layers.Dense(1000, activation='relu')(input_img)
#encoded = layers.Dense(500, activation='relu')(encoded)
#encoded = layers.Dense(250, activation='relu')(encoded)
#encoded = layers.Dense(150, activation='relu')(encoded)

#encoded = layers.Dense(100, activation='relu')(encoded)
#encoded = layers.Dense(100, activation='relu')(encoded)

#decoded = layers.Dense(150, activation='relu')(encoded)
#decoded = layers.Dense(250, activation='relu')(decoded)
#decoded = layers.Dense(500, activation='relu')(decoded)
#decoded = layers.Dense(1000, activation='relu')(decoded)
#decoded = layers.Dense(28 * 28, activation='sigmoid')(decoded)

#autoencoder = Sequential()
autoencoder = keras.Model(input_img, decoded)
autoencoder.compile(optimizer='adam', loss='mean_absolute_error')
autoencoder.summary()
#autoencoder.fit(trainX, trainX,
 #               epochs=100,
 #               batch_size=1,
  #              shuffle=True)

history = autoencoder.fit(trainX, trainX, batch_size=128, epochs=100, validation_split=0.1, callbacks=[PlotLossesKeras()])

#encoder = keras.Model(input_img, encoded)
#encoded_input = keras.Input(shape=(width * width * 3,))
#decoder_layer = autoencoder.layers[-1]
#decoder = keras.Model(encoded_input, decoder_layer(encoded_input))


#encoded_imgs = autoencoder.predict(trainX_noise)

import matplotlib.pyplot as plt

encoded_imgs = autoencoder.predict(testX)

n = 10  # How many digits we will display
plt.figure(figsize=(40, 8))
for i in range(n):
    # Display original
    ax = plt.subplot(2, n, i + 1)
    plt.imshow(cv2.cvtColor(testX[i].reshape((width, width, 3)), cv2.COLOR_BGR2RGB))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

    # Display reconstruction
    ax = plt.subplot(2, n, i + 1 + n)
    plt.imshow(cv2.cvtColor(encoded_imgs[i].reshape((width, width, 3)), cv2.COLOR_BGR2RGB))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()

import matplotlib.pyplot as plt

encoded_imgs = autoencoder.predict(testX_noise)

n = 10  # How many digits we will display
plt.figure(figsize=(40, 8))
for i in range(n):
    # Display original
    ax = plt.subplot(2, n, i + 1)
    plt.imshow(cv2.cvtColor(testX_noise[i].reshape((width, width, 3)), cv2.COLOR_BGR2RGB))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

    # Display reconstruction
    ax = plt.subplot(2, n, i + 1 + n)
    plt.imshow(cv2.cvtColor(encoded_imgs[i].reshape((width, width, 3)), cv2.COLOR_BGR2RGB))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()

import matplotlib.pyplot as plt


n = 10  # How many digits we will display
plt.figure(figsize=(20, 4))
for i in range(n):
    # Display original
    ax = plt.subplot(2, n, i + 1)
    plt.imshow(x_train_noisy[i].reshape((28, 28)))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

    # Display reconstruction
    ax = plt.subplot(2, n, i + 1 + n)
    plt.imshow(encoded_imgs[i].reshape((28, 28)))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()

import matplotlib.pyplot as plt

n = 10  # How many digits we will display
plt.figure(figsize=(20, 4))
for i in range(n):
    # Display original
    ax = plt.subplot(2, n, i + 1)
    plt.imshow(trainX[i].reshape(28, 28))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

    # Display reconstruction
    ax = plt.subplot(2, n, i + 1 + n)
    plt.imshow(decoded_imgs[i].reshape(28, 28))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()